{"version":3,"sources":["doodle.js"],"names":["cc","Class","extends","Component","properties","reactivity","debug","onEnable","graphics","getComponent","Graphics","nodes","ripples","mouse","x","y","color","r","g","b","a","cycle","createBezierNodes","canvas","find","on","Node","EventType","TOUCH_START","touch","event","getLocation","addRipple","TOUCH_END","input","updateColorCycle","quantity","len","theta","Math","PI","winSize","width","cos","height","sin","push","vx","vy","lastX","lastY","min","max","disturb","orbit","angle","random","speed","length","fade","update","dt","ease","friction","index","ripple","splice","forEach","call","node","render","currentIndex","nextIndex","xc","yc","clear","strokeColor","fromHEX","fillColor","lineWidth","moveTo","N","quadraticCurveTo","fill","stroke","lineCap","LineCap","ROUND","lineJoin","LineJoin","lineTo","circle"],"mappings":"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","file":"doodle.js","sourceRoot":"..\\..\\..\\..\\..\\..\\assets\\cases\\graphics\\demo","sourcesContent":["// http://codepen.io/Francext/pen/ojwdJ\n\ncc.Class({\n    extends: cc.Component,\n\n    properties: {\n        reactivity: 0.5,\n        debug: false\n    },\n\n    // use this for initialization\n    onEnable: function () {\n        this.graphics = this.getComponent(cc.Graphics);\n\n        this.nodes = [];\n        this.ripples = [];\n        this.mouse = { x: 0, y: 0 };\n        this.color = { r: 0, g: 0, b: 0, a: 255 };\n        this.cycle = 90;\n\n        this.createBezierNodes();\n\n        let canvas = cc.find('Canvas');\n        canvas.on(cc.Node.EventType.TOUCH_START, function (touch, event) {\n            this.mouse = touch.getLocation();\n            this.addRipple();\n        }, this);\n        canvas.on(cc.Node.EventType.TOUCH_END, function () {\n            this.input = false;\n        }, this);\n    },\n    \n    createBezierNodes: function () {\n    \n        this.updateColorCycle();\n    \n        for(var quantity = 0, len = 6; quantity < len; quantity++) {\n                \n            var theta = Math.PI * 2 * quantity / len;\n            \n            var x = cc.winSize.width * 0.5 + 0 * Math.cos(theta);\n            var y = cc.winSize.height * 0.5 + 0 * Math.sin(theta);\n            \n            this.nodes.push({\n                    \n                x: x,\n                y: y,\n                vx: 0,\n                vy: 0,\n                \n                lastX: x,\n                lastY: y,\n                \n                min: 150,\n                max: 250,\n                disturb: 150,\n                \n                orbit: 20,\n                angle: Math.random() * Math.PI * 2,\n                speed: 0.05 + Math.random() * 0.05,\n                                                \n                theta: theta\n            \n            });\n                    \n        }\n    },\n\n    addRipple: function() {\n\n        this.input = true;\n        \n        if(this.ripples.length === 0) {\n    \n            this.updateColorCycle();\n    \n            this.ripples.push({\n        \n                x: this.mouse.x,\n                y: this.mouse.y,\n            \n                reactivity: 0,\n                fade: 1.0\n        \n            });\n            \n        }\n    \n    },\n    \n    updateColorCycle: function () {\n    \n        this.cycle = Math.min(this.cycle + this.reactivity + 0.3, 100) !== 100 ? this.cycle += this.reactivity + 0.3 : 0;\n        \n        let color = this.color;\n        color.r = ~~(Math.sin(0.3 * this.cycle + 0) * 127 + 128);\n        color.g = ~~(Math.sin(0.3 * this.cycle + 2) * 127 + 128);\n        color.b = ~~( Math.sin(0.3 * this.cycle + 4) * 127 + 128);\n    \n    },\n\n    // called every frame, uncomment this function to activate update callback\n    update: function (dt) {\n        let nodes = this.nodes;\n        let ripples = this.ripples;\n\n        var ease = 0.01, friction = 0.98;\n        \n        for(var index = 0; index < ripples.length; index++) {\n        \n            var ripple = ripples[index];\n        \n            ripple.reactivity += 5;\n            ripple.fade -= 0.05;\n            \n            if(ripple.fade <= 0.0)\n            \n                ripples.splice(index, 1);\n                \n        }\n    \n        [].forEach.call(nodes, (node, index) => {\n                        \n            node.lastX += (cc.winSize.width * 0.5 + node.disturb * Math.cos(node.theta) - node.lastX) * 0.08;\n            node.lastY += (cc.winSize.height * 0.5 + node.disturb * Math.sin(node.theta) - node.lastY) * 0.08;\n            \n            // Motion\n            node.x += ((node.lastX + Math.cos(node.angle) * node.orbit) - node.x) * 0.08;\n            node.y += ((node.lastY + Math.sin(node.angle) * node.orbit) - node.y) * 0.08;\n        \n            // Ease\n            node.vx += (node.min - node.disturb) * ease;\n        \n            // Friction\n            node.vx *= friction;\n            \n            node.disturb += node.vx;\n            \n            if(this.input)\n                                \n                node.disturb += (node.max - node.disturb) * this.reactivity;\n                                    \n            node.angle += node.speed;\n            \n        });\n\n        this.render();\n    },\n\n    render: function () {\n        let nodes = this.nodes;\n        let ripples = this.ripples;\n        let graphics = this.graphics;\n        let color = this.color;\n    \n        var currentIndex, nextIndex, xc, yc;\n\n        color.a = this.debug ? 255 : 255/2;\n\n        graphics.clear();\n                        \n        [].forEach.call(nodes, (node, index) => {\n    \n            currentIndex = nodes[nodes.length - 1];\n            nextIndex = nodes[0];\n                \n            xc = currentIndex.x + (nextIndex.x - currentIndex.x) * 0.5;\n            yc = currentIndex.y + (nextIndex.y - currentIndex.y) * 0.5;\n        \n            let strokeColor = cc.color().fromHEX(this.debug ? '#a9a9a9' : '#e5e5e5');\n            strokeColor.a = this.debug ? 255 : 255/2;\n            graphics.strokeColor = strokeColor;\n\n            graphics.fillColor = color;\n            graphics.lineWidth = this.debug ? 1 : 5;\n\n            graphics.moveTo(xc, yc);\n            \n            // Draw through N points\n            for(var N = 0; N < nodes.length; N++) {\n                \n                currentIndex = nodes[N];\n                nextIndex = N + 1 > nodes.length - 1 ? nodes[N - nodes.length + 1] : nodes[N + 1];\n                \n                xc = currentIndex.x + (nextIndex.x - currentIndex.x) * 0.5;\n                yc = currentIndex.y + (nextIndex.y - currentIndex.y) * 0.5;\n            \n                graphics.quadraticCurveTo(currentIndex.x, currentIndex.y, xc, yc);\n                \n            }\n\n            this.debug ? null : graphics.fill();\n            graphics.stroke();\n                        \n            graphics.lineWidth = 1;\n            graphics.lineCap = cc.Graphics.LineCap.ROUND;\n            graphics.lineJoin = cc.Graphics.LineJoin.ROUND;\n            graphics.strokeColor.fromHEX('#a9a9a9');\n            graphics.fillColor.fromHEX('#a9a9a9');\n            \n            // Draw through N points\n            for(var N = 0; N < nodes.length; N++) {\n                \n                // First anchor\n                currentIndex = nodes[N];\n                nextIndex = N + 1 > nodes.length - 1 ? nodes[N - nodes.length + 1] : nodes[N + 1];\n                \n                xc = currentIndex.x + (nextIndex.x - currentIndex.x) * 0.8;\n                yc = currentIndex.y + (nextIndex.y - currentIndex.y) * 0.8;\n                \n                graphics.moveTo(xc, yc);\n                \n                // Second anchor\n                currentIndex = nextIndex;\n                nextIndex = N + 2 > nodes.length - 1 ? nodes[N - nodes.length + 2] : nodes[N + 2]; \n                \n                xc = currentIndex.x + (nextIndex.x - currentIndex.x) * 0.2;\n                yc = currentIndex.y + (nextIndex.y - currentIndex.y) * 0.2;\n                \n                graphics.lineTo(xc, yc);\n                graphics.stroke();\n                \n                // First anchor\n                currentIndex = nodes[N];\n                nextIndex = N + 1 > nodes.length - 1 ? nodes[N - nodes.length + 1] : nodes[N + 1];\n                \n                xc = currentIndex.x + (nextIndex.x - currentIndex.x) * 0.8;\n                yc = currentIndex.y + (nextIndex.y - currentIndex.y) * 0.8;\n                \n                graphics.circle(xc, yc, 2);\n                graphics.fill();\n            \n                // Second anchor\n                currentIndex = nextIndex;\n                nextIndex = N + 2 > nodes.length - 1 ? nodes[N - nodes.length + 2] : nodes[N + 2]; \n                \n                xc = currentIndex.x + (nextIndex.x - currentIndex.x) * 0.2;\n                yc = currentIndex.y + (nextIndex.y - currentIndex.y) * 0.2;\n                \n                graphics.circle(xc, yc, 2);\n                graphics.fill();\n                \n            }\n\n        });\n        \n        for(var index = 0; index < ripples.length; index++) {\n        \n            var ripple = ripples[index];\n            \n            let fillColor = cc.color().fromHEX('#ffffff');\n            fillColor.a = ripple.fade * 255;\n            graphics.fillColor = fillColor;\n            \n            graphics.circle(ripple.x, ripple.y, ripple.reactivity);\n\n            graphics.fill();\n        }\n                    \n    }\n});\n"]}